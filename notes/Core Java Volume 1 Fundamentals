-The Java Development Kit (JDK) consists of over 4000 classes for many things -  database support, XML processing, UI construction, security, etc. 
-This book covers Java Standard Edition (SE) 9, 10, & 11 
______________________________________________________________________________________________________________________
CHAPTER 1: INTRODUCTION TO JAVA 
-Java is not just a language, it is a whole platform with a giant library and execution environment 
-Java excluded a variety of C++ features: header files, pointer syntax, structs, unions, operator overloading, virtual base classes, & more 
-One design priority of Java was for it to have a pretty small memory footprint to enable it to run on small machines. Now, Java Micro Edition is used for that
-instead of multiple inheritance, Java uses interfaces 
-the pointer model in Java eliminates the possibility of overwriting memory / corrupting data 
-Java browser plugins do not trust remote code unless it's digitally signed & the user has agreed to its execution, due to past security exploits
-the object files (bytecode) generated by the java compiler are architecture neutral, because it runs on the JVM. 
-bytecode is translated into architecture-specific code via interpretation / JIT compilation
-Javas UI libraries portability between all the various OSs remains an issue, but most other Java libraries (even threads) have good portability
-jshell, the Java interpreter, was introduced in JDK 9 (i.e. Java 9) and can execute bytecode on any machine it runs on 
-JIT compilation is the more typical method 
-Java generally more dynamic than C/C++, and is capable of adding & running code at run time 
-Java applet: a web program that runs in a java enabled browser 
-Java applets are embedded elements within a web page. 
-Java applets are generally no longer used, and it requires effort to get them working in a browser 
-Java is generally used in server-side programming and cross-platform client applications 
-Oracle has committed to keeping Java opensource, though currently you must pay royalties if developing for embedded systems, but that will end in 10 years. 
-Java was originally interpreted (by the VM, not jshell?), JIT was added later 
-Android is built with Java 
______________________________________________________________________________________________________________________ 
CHAPTER 2: THE JAVA PROGRAMMING ENVIRONMENT 
-first download & install the JDK (java development kit). Remember, on windows you don't want to have spaces in the install path. Also update the path
-starting w/ Java 9 you must have a 64 bit OS to use the JDK 
-Here is a list of common Java jargon: 
    JDK                 Java Development Kit
    JRE                 Java Runtime Environment; for Java 10 or prior, contains the virtual machine by itself. Not for developers, does not contain a compiler.
    Server JRE          the software for running Java on servers
    SE                  Standard Edition; Java platform for use on desktops & simple server applications. 
    EE                  Enterprise Edition; Java platform for complex server applications 
    ME                  Micro Edition; Java platform for use on small devices 
    JavaFX              an alternate tookit for GUIs, including with certain SE distributions prior to Java 11 
    OpenJDK             opensource implementation of Java SE 
    J2                  Java 2; outdated term describing old Java versions 1.2-1.4 and 5.0. Thus you had terms like J2SE SDK 5.0
    SDK                 Software Development Kit; outdated term for the JDK of Java 1.2-1.4 and 5.0. 
    u                   Update; u was Oracles term for an update prior to Java 8, apparently ... 
    NetBeans            Oracles IDE 

-to test whether you installed the JDK correctly: 
    < javac --version 

-the Java library source files are in the JDK folder under lib/src.zip. create a folder and unzip the source in there (why? for exploration I think)
-if you want more source (for the compiler, VM, native methods, private helper classes) go to http://openjdk.java.net 
-you can also download the docs at: www.oracle.com/technetwork/java/javase/downloads 
-also, read the API documentation for a list of native classes & methods: http://docs.oracle.com/javase/9/docs/api 

-to compile & run a program: 
    < javac script.java                         // this is the compiler. It creates script.class, the bytecode 
    < java script                               // this launches the VM & runs script.class 

-jshell is similar to Pythons interpreter shell, and was added in Java 9: 
    < jshell 
    jshell> "string".length(); 
    $1 ==> 6                                    // $1 is the variable the result was assigned to 
    jshell> 5 * $1;
    $2 ==> 30 
    jshell> int var1 = $2 / $1; 
    var1 ==> 5 
    jshell> Math.   (press tab)         // press tab while typing an object name with a period after it to get all its methods / properties
    ... 
    jshell> Math.p  (press tab)         // press tab after writing letters to get the properties beginning with those letters 
    ... 
______________________________________________________________________________________________________________________
CHAPTER 3: FUNDAMENTAL PROGRAMMING STRUCTURES 

    print_hello.java: 
        public class print_hello{
            public static void main(String[] args){
                System.out.println("hello!..."); 
            }
        }
    < javac print_hello.java
    < java print_hello 

-the keyword public is the "access modifier". It controls access of other parts of the program to this code. read CH5 for more info 
-everything in a Java program must be inside a class 
-Java always begins execution of the program in the main method of the class indicated 
-the main must be declared with the syntax: public static void main(String[] args)
-void indicates that the main does not return an exit code (unlike C/C++). To terminate with an exit code, use System.exit() 
-System.out.println() adds a newline to the end, System.out.print() does not 
-There are 3 types of comments: //, /* */, and /** */. The third kind is used to automatically create documentation strings, discussed later. 
-There are 8 primitive types in Java: 
    int             // 4 bytes 
    short           // 2 bytes 
    long            // 8 bytes 
    byte            // 1 byte integer from -128 to 127
    float 
    double 
    char            // a unicode character 
    boolean 

-integer literals can use different syntax: 
    40000000000L            // long numeric literal 
    0xCA79                  // hex numeric literal. prefix can also be 0X 
    0447                    // octal numeric literal
    0b10010101              // binary numeric literal. prefix can also be 0B
    1_000_000_000           // underscores can be added to numeric literals for readability
    3.14F                   // float literal; if theres no F, the literal is auitomatically treated as a double 

-note that numeric data types sizes are platform-independent thanks to the JVM, unlike C/C++ 
-there are 3 special floating point values: Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
-you must use special comparisons to test for NaN: 

    if (Double.isNaN(x)){               // test if a floating point result is NaN 
        ... 
    }

-if you need precise floating point numbers, like for financial calculations, use the BigDecimal class instead of these numbers 

-internally, chars are implemented as UTF-16 encoded characters, which are 2 bytes
-'a' is a char, "a" is a string 
-chars can also be expressed as \u hex escape sequences: \u0000 to \uFFFF 
-similar to C++, escape sequences also include: \\, \", \n, \t, etc. 
-\u hex sequences are preprocessed, so you can use \u hex sequences outside quoted strings, within the java script itself. for example: 
    public static void main(String\u005B\u005D args) 

-\u hex inside comments or used in ways that confuse the parser can throw strange errors, so be weary: 
    // c:\users             <-- this comment generates a parsing error due to invalid hex 

-UTF-8 can be 1-4 bytes, UTF-16 can be 2-4 bytes. When Chinese, Korean, and Japanese were added to unicode, UTF was expanded beyond 2 bytes 
-the author recommends avoiding char unless manipulating UTF-16   

-unlike in C/C++, Java does not automatically convert expressions / literals to boolean values within test expressions 

-variable names must start with a unicode letter / _ / $ and be a sequence of unicode letters / digits / _ / $. unicode letters / digits can be in any language. 
-So there are invalid unicode characters for use in variables. To check if a unicode character is valid, use the following: 
    java.lang.Character.isJavaIdentifierPart(int codePoint)
    java.lang.Character.isJavaIdentifierStart(int codePoint) 

-although $ is a valid letter, it is generally reserved for use by Java internally and should be avoided 
-multiple declaration is allowed: 
    int x, y, z; 

-var is similar to auto in C++. if the type can be inferred from the literal, you can use var:  
    var number = 10;    // automatically sets type to int 

-to a declare a constant, use the final keyword: 
    final int NUMBER = 12; 

-constants are commonly made available to multiple methods inside a class, and declared public & static. these are called 'class constants': 
    public class car{
        public static final short WHEEL_COUNT = 4;                  // declaring it public means methods from other classes can use it too 

        public static void main(String[] args){    
            ... 
        }
    }

-const is a reserved Java keyword that is not currently used for anything 

-enum variables can either be one of the declared values or null
-enum declaration is as follows: 
    enum Size { SMALL, MEDIUM, LARGE }; 
    Size shirt_1 = Size.MEDIUM; 

-integer division by 0 throws an error, while floating point division by 0 yields Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY
-there's a strictfp keyword that can be used to maintain completely reproducible values for floating point numbers across systems. 
-strictfp does this by truncating some systems precision and decreasing performance, so it's not ideal except when exact reproducibility is completely necessary.
-one example use of strictfp is as follows: 
    public static strictfp void main(String[] args)             // causes all methods to use strict floating point calculations 

-Math is a native Java class: 
    Math.sqrt(100);             // 10. sqrt is internally implemented as a static method, apparently 
    Math.pow(2, 3);             // 8 
    Math.floorMod();            // if you mod a negative number with this mod, the result will still be positive - not so with the regular mod. google for details 
    Math.PI 
    Math.E 
    Math.sin()                  // google for details 

-to avoid having to prefix these methods with Math every time, use a static import (CH 4): 
    import static java.lang.Math.*; 

-Apparently Math performs calculations in floating point registers on the CPU by default, but this can introduce unpredictability into the results.
-For total portability but truncation / decreased performance across all Math methods, use StrictMath

-The following Math methods can be used instead of the conventional operators, and will throw errors if overflow occurs: 
    Math.multiplyExact() 
    Math.addExact()                             // all these can handle int and long parameters
    Math.subtractExact() 
    Math.incrementExact() 
    Math.decrementExact() 
    Math.negateExact()

-chars automatically convert to ints 
-ints & longs automatically convert to floats & doubles. They can technically lose precision in the process if the ints / longs are too big 
-typecasts are done w/ preceding parenthesis: 
    double x = 10.5; 
    int y = (int) x; 

-to round a number use (int) Math.round(): 
    double x = 10.5; 
    int y = (int) Math.round(x);            // you must typecast Math.round() because it returns a long. Note there is a possibility of information loss

-you can't typecast between booleans & other types 

-the following operators are the same in Java as C++: 
    combined operators 
    increment / decrement operators 
    boolean expressions 
    ternary operator
    bitwise operators (& | ^ ~)


-bit shift operators (>> <<) are similar, but >> fills the high bits with 1s and >>> fills the high bits with 0s. 
-In C/C++, arithmetic vs logical shift is undefined and implementation dependent

-Java allows a coma-separated list of expressions in the 1st and 3rd slots of the for loop 

-Java strings are sequences of UTF characters 
-strings are instances of the String class: 
    String str = "hello"; 
    String str2 = str.substring(0, 3);      // hel - 2nd parameter is the index to stop before 
    

-use + to concatenate strings. non string values are automatically converted to strings 
-the join method concatenates strings while inserting a delimiter. 
-the repeat method creates a repeating string: 
    String.join(",", "A", "B", "C");        // A,B,C    
    "v^".repeat(3);                         // v^v^v^ 

-Java strings are immutable, unlike C/C++ 

-for efficiency, most duplicate strings are shared in memory, but this is not always possible. 
-strings are implemented using pointers, and you can set a String variable to null. 
-you must use special comparison methods to compare strings, == will only compare the pointer values. == will work if the string is shared, but unreliably
-the UTF characters in strings are 1 code point (1 byte) for common characters, 2+ code points for others:  
    
    String str1 = "blah"; 
    String str2 = "blah"; 
    String str3 = "Blah"; 
    String str4 = null; 
    
    if (str1 != null && str1.equals(str2)){                         // generally you must test whether a string is null before calling a method on the string 
        ... 
    }
    if (str1 != null && str1.equalsIgnoreCase(str3)){               // string comparison, bug ignores case 
        ...
    }

    int UTF16_unit_count = str2.length();                           // length gets the number of "code units in UTF-16" - the actual 2 byte chunks of UTF-16 
    int code_point_count = str3.codePointCount(0, str3.length());   // gets the total individual code points, or bytes, in the string  
    char UTF16_unit = str3.charAt(1);                               // get the 2nd UTF16 code character in the string 

    int index = str3.offsetByCodePoints(0, 1);                      // this is how you get individual code points, apparently... no idea why they'd do it this way
    int code_point = str3.codePointAt(index);                       // I don't think you actually need to get the index first, the author used this, but who knows 

    int[] code_points_array = str3.codePoints().toArray();          // get an array of integers for all the code points 
    String reconstructed_string = new String(code_points_array, 0, code_points_array.length);      // reconstruct the string from the code points 

-to add more madness, the JVM does not have to implement strings as code unit sequences. If there are only 1 byte chars in the string, it can use a byte array. 
-the author recommends not using chars at all due to the complete and utter mess that is seen above 
-IMO if you know there won't be any strange characters in the string you can probably just use them, we'll see... 

-some final functions of the String class: 
    String.compareTo(other_string);             // return negative # if String comes before other_string, 0 if they're equal, and a positive # otherwise
    String.blank();                             // if String consistsn only of whitespace, return true 
    String.empty();                             // if String is "", return true 
    String.endsWith(suffic);                    // if String ends with the suffic, return true 
    String.indexOf(str2, starting_index);       // search for str2 in the String, 2nd index is optional 
    String.lastIndexOf(str2, starting_index);
    String.replace(old_string, new_string);     // return a string with all instances of old_string replaced by new_string 
    String.trim() / String.strip()              // removes all chars that are below ASCI 33 (trim) or whitespace (strip) 

-You can also pass strings to parameters of an interface type called CharSequence (covered more later) 

-Occasionally, you need to build up a string from individual characters, such as keystrokes. 
-It's inefficient to use concatenation for this, because a new String object must be created each time. Instead, use the StringBuilder class: 

    StringBuilder str1 = new StringBuilder(); 
    str1.append('a'); 
    str1.append('b'); 
    ... 
    String final_string = str1.toString(); 

-the following code allows you to read input from the command line (which is not set up by default): 
    import java.util.*;                                     // contains the Scanner class
    ... 
    Scanner scanner = new Scanner(System.in);               // the Scanner class contains a variety of methods for reading input
    
    System.out.print("enter name: "); 
    String name = scanner.nextLine();                       // nextLine() gets a full line of input from the console 
    
    System.out.print("enter your favorite color: ");
    String color = scanner.next();                          // next() just gets a word, delimited by whitespace 

    System.out.print("enter age: "); 
    int age = scanner.nextInt();                            // nextInt() gets an integer. likewise, nextDouble() gets a double. 

-you should not use Scanner to read a password from the console, because it's insecure. Instead you must use the Console class, introduced in Java 6: 
    Console console = System.console(); 
    String username = console.readline("Username: "); 
    char[] password = console.readPassword("Password: ");   // the method arbitrarily uses char[] instead of String, no explanation for why, maybe security 

-for formatting output, Java has the same old printf function 
-there are a variety of flags that can precede a printf specifier, read the documentation for details:   
    System.out.printf("%d, %,.2f", 12, 17.457);                         // the , in %,.2f is one such flag which inserts commas in the output 

-to printf format custom objects: if the object implements the Formattable interface, the objects formatTo() method is invoked; otherwise toString() is invoked
-to store a similarly formatted string in a variable use String.format() 
-these format strings have an outdated Date formatter, but it's better to use the newer java.time package instead.  
    String formatted_string = String.format("%tc", new Date());         // prints the current date time, but use the new java.time package 

-you can associate the %'s with a specific argument using the $ syntax. You'd often use this with Date() objects to associate multiple %'s with 1 Date. 
-The < syntax is an alternative, which connects the current % with the previous %'s argument.  
    System.out.printf("%2$,.2f, %1$d", 12, 17.457);             // 2$,.2f connects with the 2nd arg, %1$d connects with the 1st arg 
    System.out.printf("%.2f, %<d", 12.357); 

-To read from a file you again use the Scanner class. 
-1st arg must use Path.of() because if you use a raw string, the scanner interprets the raw string as a string of input data
-2nd arg is the files character encoding, which helps with consistency / portability. If not provided, the computers default encoding is used: 
    Scanner scanner = new Scanner(Path.of("file.txt"), StandardCharsets.UTF_8);             // what an ugly syntax, if the file contains \, remember to use \\
    String line = scanner.nextLine();

-Similarly, to write to a file, use the PrintWriter class: 
    Printwriter printwriter = new PrintWriter("file.txt", StandardCharsets.UTF_8);

-the current directory is determined by where the JVM runs, and this can vary depending on how the program is run (like if you run it in an IDE).
-to get the current directory programmatically, get the "user.dir" System property: 
    String current_directory = System.getProperty("user.dir"); 

-Java throws an IOException if you try to open a file that doesn't exist or create a file that can't be created. 
-To handle an IOException use the following (more detail later): 
    public static void main(String[] args) throws IOException{
        Scanner scanner = new Scanner(Path.of("file.txt"), StandardCharsets.UTF_8); 
        ...
    }

-Another way to handle file i/o is by using pipes in the shell to set stdin / stdout and use that within the code: 
    java scriptname < infile.txt > outfile.txt 

-loops & control flow is all identical to C++ with a few exceptions: there's no goto, there's a labeled break / continue, and something about foreach
-even obscure things are identical: ternary operators, switch statements, do while, etc. 
-you can apply a label to any statement using the block syntax. this can be used to simulate goto if necessary 
    label_name:                 // a label for a named break / continue statement. place the label before the block you want to break out of 
    while(true){
        while (true){
            ... 
            break label_name; 
        }
    }
    label_name2:                // apply a label to a plain block to simulate goto 
    {
        ...
        if (condition){
            break label_name2; 
        }
    }

-for big numbers there's BigInteger and BigDecimal (for floats): 
    BigInteger num1 = BigInteger.valueOf(100);                      // this syntax can be used if the number is small. Not sure why you'd use it, but it exists 
    BigInteger num2 = new BigInteger(123455677345234513456");       // this syntax is for large numbers. Not sure how large, I'm assuming larger than a long 
    BigInteger sum1 = num1.add(num2);                               // use methods to perform arithmetic operations '
    BigInteger product1 = sum1.multiply(num1); 
    BigInteger sum2 = sum2.add(BigInteger.ONE);                     // BigInteger.ONE is a constant provided by the class. There's also BigInteger,ZERO, & others

-one major downside of Java is it does not allow operator overloading 

-Java uses its own array declaration syntax: 
    int[] array1 = new int[100];                    
    int[] array2 = {1, 2, 3, 4, 5};                 // a shorthand for declaring a 5 element array with these values 
    array2 = new int[] {1, 2, 3, 4, 5, 6, 7};       // you can set the old array variable to a new "anonymous array" with this syntax 
    int[] array3 = new int[0];                      // you can have a 0 length array - useful if you need to return an empty array or something 

    array1.length;

-String arrays without initial values are initialized with nulls, not empty strings; int arrays are initialized with 0; boolean arrays are initialized with false 

-the for:each loop can iterate through anything that implements the Iterable interface: 
    for (int x : array1){                                   // they call it a foreach loop, but there is no foreach keyword
        ...
    }

-you can stringify an array w/ toString() 
-when you assign one array variable to another, both point to the same object in memory 
-to sort an array of integers, use Arrays.sort()
-to get a true copy of the array, use copyOf(). 
-copyOf() is commonly used to increase the size of an array 
-multidimensional arrays are implemented with pointers to arrays. you can actually change the arrays being pointed to: 
    int[] array1 = {3, 2, 1};

    Arrays.sort(array1);                                                // [1, 2, 3]
    Arrays.toString(array1);                                            // "[1, 2, 3]" 
    int[] array2 = Arrays.copyOf(array1, array1.length * 2);            // 2nd argument specifies how many values to copy, and default initializes the overflow 
    
    int[][] array_2d = {
        {1, 2, 3}, 
        {4, 5, 6}, 
        {7, 8, 9}
    }
    for (int x: array_2d){
        for (int y: x){
            ... 
        }
    }
    Arrays.deepToSTring(array_2d);                                      // "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"

    array_2d[1] = array1; 
    array_2d[2] = array2;

    int[][] jagged_array = new int[5][];                                // this is how you create a jagged array 
    for (int x = 0; x < 5; x++){
        jagged_array[x] = new int[x + 1]; 
    }

-java arrays are dynamic, similar to C++ heap arrays. they also have automatic bounds checking built into them 
-unlike in C/C++, the program name is not stored in args[0] of the main; args[0] is the first argument 
-to get a random number, use Math.random(), which is similar to javascripts: 
    int roll = (int) (Math.random() * cap);

______________________________________________________________________________________________________________________
CHAPTER 4: OBJECTS AND CLASSES 
-a good way to start an OOP project is to identify the classes and start writing methods 
-to identify classes, look for important nouns in the project description; for methods, look for important verbs 
-3 common relationships between objects are: 
    dependence (Y uses an X)        // Ys methods use an X somewhere in them. Try to minimize dependence, you want to keep objects decoupled 
    aggregation (Y has an X)        // aggregation is containment - the Y object contains one or more Xs. some prefer to think of it as association instead 
    inheritance (Y is an X)         // general vs specialized versions of the object 

-typically you draw UML diagrams to map out relationships between classes 

-object variables are pointers to the object
-create objects w/ new & the object constructor: 
    Date date1 = new Date();                            // invokes the objects constructor 
    String date2 = new Date().toSTring();               // you can call methods right off the constructor of an object, though it's not the most efficient method
    date1 = null;                                       // object variables can be null 

-objects are always created on the heap 
-the garbage collector automatically cleans up the heap 
-to get a complete copy of an object you must use the clone method in Java 

-There are 3 common classes for handling dates: Date, which handles the timestamp, and LocalDate / GregorianCalendar, which both handle the calendar aspect 
-You don't invoke a LocalDate constructor. Instead, it contains factory methods that act like constructors 
-with LocalDate / GregorianCalendar you can do things like increment the date by a number of days 
-LocalDate returns new objects using functors, while GregorianCalendar works on 1 object and modifies its date in place:  
    LocalDate now = LocalDate.now(); 
    LocalDate millennium = LocalDate.of(2000, 1, 1); 
    LocalDate future_date = now.plusDays(1000);                             // increment the date by 1000 days
    int future_day = future_date.getDayOfMonth(); 
    int future_month = future_date.getMonthValue(); 
    int future_year = future_date.getYear(); 

    int current_date = now.getDayOfMonth(); 
    LocalDate past_date = now.minusDays(current_date - 1);                  // sets to start of month  

    GregorianCalendar myahn_date = new GregorianCalendar(2012, 12, 12); 
    myahn_date.add(Calendar.DAY_OF_MONTH, 1);                               // the Calendar class is necessary to work with GregorianCalendar, apparently 
    int survived_day = myahn_date.get(Calendar.DAY_OF_MONTH); 
    int survived_month = myahn_date.get(Calendar.MONTH); 
    int survived_year = myahn_date.get(Calendar.YEAR); 

-the Date class has getMonth, getDay, and getYear methods but apparently they're deprecated 
-the JDK provides a tool called jdeprscan that can scan your script for deprecated code 

-Java programs have 1 or more classes, and at least 1 main method defined in a class. 1 main method runs to start the program
-you can include multiple classes in 1 file, and split up classes into multiple files 
-when you compile a file, the java compiler searches for all dependency classes and compiles those files also. thus you do not have to specify all files 
-if you have old compiled files, the java compiler will recompile them automatically if changes were made to the files 

    public class class_name{
        private int[] int_array = new int[100]; 
        private class_name_2 object1 = new class_name_2();              // it's common in java for classes to contain other classes as data, apparently 

        public static void main(String[] args){
            ...            
        }

        public class_name(){                                            // constructor 
            ...
        }
        public class_name(int x){                                       // 2nd constructor 
            ...
        }
        public method1(int x, int y){
            ...
        }
        private method2(String x, String y){
            ...
        }
    }

-the public methods are accessible by any method from any class 
-the private methods are only accessible by methods within the class 
-typically all data fields are set to private to maintain encapsulation 
-constructors are always called with new, and you can have multiple constructors
-note that the var type (like auto) can only be used inside methods, for local variables. probably because it's dynamic

-a method called off an object that's null will cause a NullPointerException
-you should thus avoid allowing private variables to be accidentally initialized to null through their constructors. 
-Java provides a quick way to replace nulls, if desired: 
    string private_variable = Objects.requireNonNullElse(input_value, "unknown");       // the second argument is the alternative to null, a string in this case 

-in Java, are methods are written inside the class. The JVM decides which methods are inline or not 
-the "this" keywords appears to be optional and a question of style in Java; the target object is assumed implicitly 
-one characteristic of using only getter methods is you make the variables read-only 
-the advantage of using getter / setter methods over public variables is, if the classes implementation changes, only those methods need changing; and setter methods can do error checking 
-make sure not to return a reference to a mutable object with a getter method - this violates encapsulation. clone the object before returning it: 
    ... 
    private private_date; 
    ... 
    public Date date_getter(){
        return (Date) private_date.clone();                         // not sure why the cast to Date is used 
    }

-methods can actually access the private data of all objects of the same class. apparently this is true in C++ also 
-final makes a variable immutable (i.e. constant). these variables must be initialized in the constructor, and cannot be changed afterward 
-final reference variables merely will never change the object they point to - the object itself is mutable 
    class obj{
        private final int data; 
        obj(int data_input){
            data = data_input; 
        }
    }

-static variables have 1 copy per class, like in C++ 
-public final static variables are a common use of static. Math.PI, System.out are examples of these static constants
-static methods have no implicit object, and cannot access an objects unique variables, like in C++
-use static methods when you only need to manipulate static variables or input parameters. example: Math.pow()
-you can access static variables / methods off the class name or an objects name
-static methods are often used to implement factory methods. this allows you to vary the type of the constructed objects, & give the construction method a name
-the main method is static so that it can be called without first creating an object 
-every test can have a main method. this is a good way of unit testing - run the classes by themselves to run the unit tests 

-All Java parameters are call by value, but objects/arrays pass copies of their pointer, so the object can be modified. however, you couldn't change the pointer 
-this means that a method can't make an object parameter refer to a new object/array, but it can change the object/array

-Java overloading works by matching type parameters, like in C++; and you can overload any method, not just constructors 
-private data members are initialized to a 0/false/null if they aren't set in the constructor, and local method variables are not (as you'd expect) 
-a default constructor will set all private data members to 0/false/null unless it's overridden 
-if you define any constructor for a class the default constructor is no longer provided 
-you can initialize the privata data members within the class too (unlike in C++, where you have to use the initializer list). 
-you can even initialize private data members using method calls: 
    class obj1{
        private String name = "unknown"; 
        private int id = get_id(); 
        private static int count = 0; 
        
        private static int get_id(){
            count++; 
            return count; 
        }
    }

-in Java, the first line in a constructor can be a call to another constructor using this(): 
    class obj2{
        private int data_1; 
        private int data_x;
        obj2(){
            data_1 = 1; 
        }
        obj2(int x){
            this();                 // this() must be on the first line of the constructor 
            data_x = x; 
        }
    }

-another pattern is initialization blocks, which always run before any constructor 
-always put your initialization blocks after the declarations of your private data members 
-apparently all initialization blocks in the class are run prior to constructors, but using only one block is simpler: 
    class obj3{
        private int id; 
        private static int count = 0;       // this is called a "field initializer" - instance variables initialized outside the constructor 
        private String name; 
        
        {                   // initialization block. for compilation reasons put the block here, below the private data members 
            count++;        // this allows you to put code that you want to run every time all in one place 
            id = count; 
        }
        obj3(String name){
            this.name = name;       // using this., which is optional, avoids having to come up with different names for the parameters & the instance variables 
        }                           // this. is also used within constructors to invoke other constructors of the same class
    }

-when a constructor is called, the following occur in order: 
    1) if this() is found on the first line, that constructor is invoked 
    2) all instance variables are initialized to 0/false/null 
    3) all field initializers and initialization blocks are run 
    4) the constructor runs 

-there are also static initialization blocks to initialize static variables. Both of these run during compilation: 
    class obj4{
        private int id; 
        private static int count;               // in this case count isn't initialized using a field initializer 
        
        static                                  // precede the initialization block with static to make it a static initialization block 
        {
            count++; 
            id = count; 
        }
        ...
    }

-Java does not have destructors, and has automatic garbage collection. 
-Sometimes you do need to close things, like files or other objects using system resources, before the object is cleaned up. There are 4 ways of doing this: 
    1) define a close method to call when you are done with the object (ch7)
    2) use Runtime.addShutdownHook to perform the cleanup once the JVM exits 
    3) use the Cleaner class (java 9) to register an action that's performed prior to garbage collection 
    4) there's a deprecated method called finalize that's unreliable and should never be used 

-packages are a collection of classes. note this isn't just a single class file, it's a folder of files. multiple files can specify the same package name. 
-packages provide a unique namespace for the classes and modularize the code 
-you can access any public class from another package by using the package name or an import statement: 
    java.time.LocalDate today = java.time.LocalDate.now(); 
    OR
    import java.time.*;                 // you can import a specific file or the whole package this way, though importing them all doesn't impact code size 
    LocalDate today = LocalDate.now();

-import does not work like include - the imported file is not pasted into the code, the java compiler finds the code (apparently). 
-importing specific files instead of using * is mainly useful for readability or avoiding name conflicts 
-the * import syntax can only import a single non-nested package
-since you can use classes without import by typing out their full pathname, the only purpose of import is convenience 
-if you want to import a static method of field you must use a special syntax: 
    import static java.lang.System.*;                   // now you can use the static methods / fields in this package 

-to designated a class file as a package use the following syntax: 
    package folder_path;    // this always goes on the first line. the folder path is relative to where the program is run, and everything besides the filenames 
    class obj1{
        ...
    }

-all classes that are not designated as packages are placed in the "unnamed package", including the main file 
-packages not in the correct folders can be compiled, but they won't run until they're placed in the right folders 
-a file must contain only 1 public class, and its name must match the file name. this limits the classes other packages can access. 
-if you neither specify private or public for a class, method, or variable, other classes within the package can use it. this breaks encpasulation w/ variables 

-JAR files are archives of multiple class files and subdirectories in a compressed format 
-Java has a "class path" variable, a list of directories that tells the JVM where to search for class files, JARs, packages, etc.. You can add new paths to it 
-when you set the class path you can specify a list of directories. If you do this, make sure to include the "." current directory. google for more details 
-you can use the * wildcard to add a folder of multiple JARs to the path (it must be escaped \* in UNIX)
-the following is the best way to set the class path. you set it as you run the program: 
    java -classpath .:path1:path2:path3 program_name                // UNIX uses : to separate paths 
    OR 
    java -classpath .:path1;path2;path3 program_name                // Windows uses ; 

-you can set the CLASSPATH environment variable in the shell, but this is error prone. Sometimes people permanently set this and it causes compilation errors 
-there's a new alternative to setting the class path in Java 9 - classes can be loaded from the module path. read chapter 9 of volume 2 for details 

-JAR archives can contain class files and other file types - images, sound files, etc. 
-JARs are zipped 
-the JDK includes a jar tool to create JAR files: 
    jar cvf jar_file_name.jar file1 file2 file3 ...                      // jar options (cvf) are similar to tar options

-each JAR contains a file MANIFEST.MF in the META-INF directory. It contains information about the JAR archive. you can edit it, read the docs for more info. 
-note that the last line in the manifest must end w/ a newline character or the parser will screw up 
-you can specify an entry program for the JAR file to make it executable). You can do this with the "e" command line option, or in the manifest (pg 194) 
-you can then run the JAR executable using java -jar: 
    jar cvfe jar_file_name.jar entry_program file1 file2 file3 ...
    java -jar jar_file_name.jar

-on Windows there are wrapper utilities that turn JAR executables into Windows executables - Launch4J adn IzPack are 2 of them 
-when Java9 introduced modules and strong package encapsulation, some APIs had to be reached differently. Java provides multi-release JARs to address this
-with multi-release JARs, you place newer Java9 copies of source files are in the META-INF/versions directory, while the old Java 7 or 8 files are used normally
-to add multi-release class files to an existing JAR or create a multi-release JAR, compile using --release (pg 196 / read docs for details) 
-do not change the API between different versions in a multi-release JAR, it is only for adjustments for different versions of the JDK

-the JDK contains a tool called javadoc that generates HTML documentation from comments starting w/ /** in your source files 
-one benefit of this approach is documentation + code is one place, preventing them from diverging over time 
-to document the file, place a comment /** ... */ immediately above each of the following: 
    modules
    packages
    public classes & interfaces
    public & protected fields
    public & protected constructors & methods

-each comment contains text and possibly certain tags, which start w/ the @ symbol -  @throws, @param, etc.. google for more info on tags
-you can put HTML tags in the comment and it will be rendered in the resulting HTML document 
-you can also use HTML links to resources (i.e. images) in your comments - create a subfolder next to the source file named "doc-files" & use it as the src: 
    /** it's a card class! <img src="doc-files/card.jpg" /> 
        @author ian rust */
    class card{
        ...
    } 
-specific tags include: 
    @param {variable description} 
    @return {return description}
    @throws {exceptions description}
    @since {description of the version that introduced this feature}
    @author {authors name, etc.}
    @version {description of current version}
    @link {links}
    @see {reference to other documentation section}
-@link and @see require a specific format: 
    general form: 
    @see package.class#feature label <a href="...">label</a>"text"      // if you omit package or class the current package or class will be used 
    @link package.class#feature label                                   // all the elements appear somewhat optional / flexible 
    examples: 
    @see coreJava.Employee#raiseSalary(double)          // creates a link to the riaseSalary method in the Employee class in the coreJava folder, left off label 
    @see <a href="www.corejava.html">text</a> label                     // if the first char is <, it expects anchor tags linked to a page in the documentation 
    @see "core java" label                                              // if the first char is ", it expects text, and puts it into a section called "see also" 

-to extract the documentation (turn it into HTML files) go into the root directory with the documentation and run one of the following commands: 
    > javadoc -d extraction_folder package_name1                        // for just 1 package. extraction folder is the new folder where the HTML will be stored 
    > javadoc -d extraction_folder package_name1, package_name2, etc.   // to document multiple packages 
    > javadoc -d extraction_folder *.java                               // for files in the unnamed package 
-javadoc has more options that you can google

-some basic principles of class design are as follows: 
    1) keep data private 
    2) initialize all data in some manner 
    3) replace groups of primitive instance variables with other objects 
    4) only provide getters / setters to fields that need it 
    5) consider breaking up classes that do too many things into smaller classes 
    6) choose self-documenting class/method/variable names. class names are generally nouns or adjective + noun
    7) make classes immutable, and instead of mutating them, return new objects. this makes them thread-safe 

______________________________________________________________________________________________________________________ 
CHAPTER 5: INHERITANCE 

-all inheritance in Java is public (different than C++) 
-Java uses the extends keyword for inheritance (C++ uses : ): 
    class type2 extends type1{
        ...
    }

-super is used to access the parents members
-super uses a different syntax to invoke the parents constructors than it does to access its methods / variables
-any call to a super constructor must be on the very first line of the constructor
-a super constructor must always be called. if you do not manually call a super constructor, the parents default constructor is called automatically. 
-then if the parent has no default constructor, an error is thrown: 

    class type2 extends type1{
        ...
        type2(int x){
            super(x);                       // calling a super constructor is necessary to initialize the parents private variables 
            ...
        }
        method_name(int x){
            super.method_name(x);           // if you need access to the parents private data you must use super w/ getter funtions 
            ...
        }
    }

-in C++, if you want a method to support polymorphism you must use the virtual keyword. 
-in Java, all overridden methods support polymorphism by default, and the keyword final is used to disallow polymorphism. 
-Java does not support multiple inheritance, but it does support inheritance chains. Interfaces provide an alternative to multiple inheritance 

-parent array references can point to their childs arrays. Java runtime monitors these polymorphic arrays to ensure parent elements are not stored in child arrays 
-when overriding methods, you can't change the return type except to a subtype of the original return type 

-private, static, or final methods, & construtors are statically bound; all other function calls are dynamically bound & therefor support polymorphism
-child methods must be at least as visible as their parent methods - i.e. if parent is public, child must be public 

-final classes cannot be extended, final methods can't be overrridden, and final fields are const. all methods in a final class are made final (but not fields)
-classes should generally be made final unless you need the polymorphism or inheritance. the compiler can inline & optimize static methods  

-typecasting works for related objects (it appears a previously converted parent can be reconverted to a child, but a true parent can't convert to a child) 
-try to use polymorphism instead of object casting if possible. if you need object casting it is a possible indication of design problems: 
    parent_type parent_obj = (parent_type) child_obj;
    ...
    if (parent_obj instanceof child_type){              // instanceof ensures this is a valid type conversion, avoiding an error 
        child_obj = (child_type) parent_obj; 
    }

-use the abstract keyword to make a class/method abstract - the equivalent of a class w/ a pure virtual method in C++
-you can create variables of abstract class types, but cannot instantiate objects of the type: 
    public abstract class obj1{     // abstract classes can have concrete fields / methods. They will have at least 1 abstract method 
        ...
        public abstract String method1();       // no implementation
    }

-protected fields/methods are accessible to all classes within the same package. the author superfluously mentions subclasses, but they're irrelevant. 
-protected fields are discouraged since they still create dependencies between parents / children; but protected methods are fine 

-the Java primitives are numbers, booleans, and chars; everything else is a class.
-all classes in Java extend / trace back to the Object superclass behind the scenes
-a variable of type Object can hold anything except primitives, though it's only useful to store things unless you know what the method calls should be: 
    Object temp = new Class1(); 
    ...
    Class1 obj1 = (Class1)temp; 

-Object has a number of useful methods that the other classes inherit 
-Object's equals() method tests if two object variables refer to the same object. 
-if you need to test whether two objects have the same state, but perhaps refer to different objects, you must override equals() in the class
-be sure to implement equals() at all levels of your class hierarchies: 
    @Override public boolean equals(Object rvalue){     // the parameter must be of type Object to successfully override the equals() method
                                                        // @Override is a decorator. If you mess up the parameters and don't override anything, it throws an error
        if (this == rvalue){                            // objects refer to the same object, return true
            return true; 
        }
        if (rvalue == null){                            // rvalue is null, return false. equals() returns true if both are null, false if only 1 are null 
            return false;
        }
        if (this.getClass() != rvalue.getClass()){      // classes don't match, return false
            return false; 
        }
        if (this.field1 == rvalue.field1 && this.field2 == rvalue.field2){      // now test the state of the two objects
            return true; 
        }
    }

-for equals() comparisons across class hierarchies you must use instanceOf() instead of getClass(). however, this introduces a few design complications
-only implement instanceOf() in the parent in a final equals() method - otherwise equals() won't be transitive between parents & children, making it unusable
-thus you use instanceOf() to compare common variables across hierarchies; use getClass() to do comparisions of subclass-specific variables 

-to compare arrays, use Arrays.equals() instead of the default Object.equals() 
-the Object class has a hashCode() method that calculates a unique hashcode for a given object using its memory address 
-the String class (and the Objects class, and numerous other classes) overrides hashCode(), and Strings get a unique hashcode based on the letters of the strings
-if you override equals(), you must also override hashCode() if you want your object to work with Java's hash tables
-to do this, calculate the new hashcode using all those fields that were used in the equals() comparison: 
    public int hashCode(){
        return 7 * Objects.hashCode(string_field) + 11 * Double.hashCode(double_field) + 13 * Objects.hashCode(date_field); 
    }
    OR 
    public int hashCode(){
        return Objects.hash(string_field, double_field, date_field);        // Objects.hash() returns a hash using a parameter list 
    }

-use Arrays.hashCode() to produce a hashcode from an array 

-Object.toString() is another important method that stringifies objects, override it to stringify your objects:  
-typically the resulting strings have the class name followed by field/value pairs inside square brackets: 
    public class obj1{
        ...
        public String toString(){
            return getClass.getName() + "[field1=" + field1 + ",field2=" + field2 + "]";
        }
    }
    public class obj2 extends obj1{
        ...
        public String toString(){       // a 2nd pair of brackets is the common way of overriding toSTring() in subclasses
            return super.toString() + "[field3=" + field3 + ",field4=" + field4 + "]";  
        } 
    }

-toString() is invoked by the Java compiler when objects are concatenated, and in output operations. It's very useful in debugging and should be overridden.    
-Object.toString() (the default) simply prints the class name followed by a hashcode for the object 
-to stringify arrays, used Arrays.toString(array1) or Arrays.deepToString(array2) for multidimensional arrays 

-The size of an array can be initialized using variables, and is static afterwards: 
    int num1 = 20; 
    var array1 = new obj1[num1]; 
    int current_length = array1.length; 

-ArrayList is Java's equivalent of Vector 
-There are multiple ways of declaring an ArrayList, & element access requires a specific syntax: 
    
    ArrayList<obj1> arraylist1 = new ArrayList<obj1>(200);  // the vector starts with 200 potential elements
    var arraylist2<obj2> = new ArrayList<obj2>(200);        // var works in Java10+ 
    ArrayList<obj3> arraylist3 = new ArrayList<>();         // if you specify the type parameter on the left, you don't need to specify it on the right
    var arraylist4 = new ArrayList(200);                    // ArrayList without <> will create an ArrayList of raw Object types 

    arraylist1.ensureCapacity(1000);                        // expands capacity in one operation, more resource efficient if you have an idea how much you need  
    arraylist1.add(new obj1());
    int current_length = arraylist1.size();                 // size() for arrayLists, length for arrays
                                                            // size() returns the actual number of elements in the vector, not the max capacity
    for (int x = 0; x < 30; x++){
        arraylist1.add(new obj1()); 
    }
    arraylist1.trimToSize();                                // trim the capacity to match the current size - preserves memory if you don't need any more capacity
    
    arraylist1.set(3, new obj1("value1"));                  // set modifies an existing element, it doesn't add an element. 
    obj1 temp = arraylist1.get(3);                          // you can't use [] accessors w/ arrayList, you must use add(), get(), and set() 

    arraylist1.add(15, new obj1());                         // inserts an element into the middle of the ArrayList 
    arraylist1.remove(12);                                  // remove an element from the middle of an ArrayList 

    for (obj1 x : arraylist1){                              // foreach loops work with ArrayLists
        x.method1();
    }

    var array1 = new obj1[arraylist1.size()]; 
    arraylist1.toArray(array1);                             // converts the ArrayList to an array after filling it up, making it easier to access elements



-page 255, new subsection










