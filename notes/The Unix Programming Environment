------------------------------------CHAPTER 1---------------------------------------
my testing in this book was conducted on a BSD system (Darwin, Mac OS X Catalina)

control characters for the terminal: 
    ctrl+d - tells a program there's no more input 
    ctrl+g - rings a bell 
    ctrl+i - tab 
    ctrl+m - alternative to the enter key 
    ctrl+c 
    ctrl+u - line kill (discards the line of input)
    ctrl+s - suspend a processes output (not sure of the details). useful for preventing something important from going offscreen, apparently
    ctrl+q - resume a processes output (again not sure of the details)

______________________________________________________
misc UNIX terminal commands: 
    date
    who                 - who is using the computer
    who am i            - your username 
    mail                - can read mail apparently. not sure what email system is being used here. there are details if you're ever interested

you can type-ahead while a prior command is running; your input may appear interleaved with output, but the system will interpret your command correctly 
______________________________________________________
ls is an important UNIX function, and has about 40 commands, most of which are worth knowing:
    ls [options] [file/path]
    ls                  - list files in current directory 
    ls <filename>       - list a specific file 
    ls -l               - long description format: file mode | # of links | owner name | group name | file size | month/day/hour/minute last modified | pathname 
                                for directories it also lists the total blocks used by files within on a separate line 
    ls -l <filename>    - long description of a specific file
    ls -l -t            
    ls -lt              - you can combine multiple options 

                // SORTING OPTIONS 
    ls -t               - sort by time last modified
    ls -rt              - reverses the order of a sort 
    ls -u               - sort by time of last access 
    ls -U               - sort by file creation time 
    ls -S               - sort by size 
    ls -c               - sort by time when file status was last changed 

                // DIRECTORY RELATED OPTIONS 
    ls <pathname>       - list files at a specific path 
    ls -R               - recursively list subdirectories 
    ls -d               - directories are listed as plain files (not searched recursively) 
    ls -A               - list all entries except for . and .. (this is always set for the superuser) 
    ls -a               - include directory entries whose name begins with a dot (.) 

                // SYMBOLIC LINK HANDLING 
                // -H, -L, and -P all override one another - the last one specified is the one used 
    ls -H               - symbolic links on the command line are followed. this option is assumed none if -F, -d, or -l are specified 
    ls -L               - follow all symbolic links to final target. list the file or directory rather than the link itsel
    ls -P               - list the link itself rather than the object the link references 

                // OUTPUT FORMATTING OPTIONS
                // -1, -C, -x, and -l override one another - the last one specified is used
    ls -C               - force multi-column output (the default behavior if output is to a terminal). note: overrides -l 
    ls -x               - same as -C, but columns are filled in horizontally instead of vertically (test it and look). note: overrides -l 
    ls -1               - force output to be one entry per line (the default if output is NOT to a terminal). note: overrides -l 

                // -B, -q, and -w override one another - the last one specified is used
    ls -B               - force printing of non-printable characters in file names 
    ls -q               - force printing of non graphic characters to be ? (the default behavior if output is to a terminal)
    ls -v               - force unedited printing of non-graphic characters (the default behavior if output is NOT to a terminal) 
    ls -w               - force raw printing of non-graphic characters (the default behavior if output is NOT to a terminal) 

                // FILE ANNOTATION OPTIONS 
    ls -p               - display '/' after each directory path 
    ls -F               - display '/' after each directory path, * after each executable, @ after each link, = after each socket, % after each whiteout, | after each FIFO 
    ls -%               - display '%' after dataless files (whiteout?), and don't materialize dataless directories when listing them 

                // LONG FORMAT SPECIFIC OPTIONS 
    ls -lh              - use suffixes for unit sizes (i.e. kilobyte, megabyte) (must combine with -l)
    ls -lO              - include the file flags (must combine with -l)
    ls -l@              - display extended attribute keys and sizes (must combine with -l)
    ls -le              - print the access control list (ACL) associated with the file, if present (must combine with -l)
    ls -lo              - omit group id (must combine with -l)
    ls -lT              - display complete date/time information (must combine with -l)

                // MISC OPTIONS
    ls -i               - print the inode# for each file 
    ls -G               - enable colored output (equivalent to defining CLICOLOR in the environment)
    ls -m               - stream output, listing files in CSV format 
    ls -n               - display user or group names as numbers rather than converting them to names. this turns on long priting (-l) automatically 

    ls -s               - display the # of blocks used by each file in units of BLOCKSIZE (environment variable) or 512 bytes by default. 
    ls -ks              - combined with -s, prints the file sizes in kb instead (so this overrides BLOCKSIZE or the default 512)

some example commands: 
    ls /                - output everything in the root directory 
    ls /usr             - list what's in the /usr directory
    
    ls -l 
    total 4296
    drwxr-xr-x@   6 vn51hvk  staff      192 May  4 00:23 Walmart.xcodeproj
    drwxr-xr-x    4 vn51hvk  staff      128 May  3 20:51 Carthage

______________________________________________________

    cat <file1> <file2>         - cat can concatenate multiple files & print their contents 
    less <filename>             - show the file in a scrollable form

    wc <file1> <file2>          - print line, word, & character counts of file(s)
        69760  140992 1998523 schema.json
    wc -l                       - print only line counts 

    tail -<number> <file>       - print the last <number> lines of a file, or default of 10 
    tail +<number> <file>       - print the remainder of the file starting at line <number> 

    sort <filename>             - sorts the lines in the file alphabetically & prints them 

common sort options: 
    -r                              - reverse sort order 
    -n                              - sort in numerical order, ignoring blanks 
    -nr 
    -f, --ignore-case               - ignore case when sorting 
    -b, --ignore-leading-blanks     - ignore leading blank characters 
    -R, --random-sort               - random permutation of the inputs except that equal keys sort together. the hash function used for comparison is chosen randomly 
______________________________________________________

    grep <pattern> <file ...>       - searches a file for a regex pattern, prints each lines occurrence
    grep -v <pattern> <file ...>    - searches for all lines without the pattern 

more noteworthy grep options: 
    -R, -r                      - recursively search subdirectories listed 
    --include-dir               - if -R is specified (for recursive), only directories matching a given filename pattern are searched. 
    --exclude-dir               - if -R is specified it excludes directories matching a given filename pattern from the search. 
                                    --exclude-dir patterns take priority over --include-dir 
    --include                   - if specified it includes directories matching a given filename pattern from the search. 
    --exclude                   - if specified it excludes directories matching a given filename pattern from the search. 
                                    --exclude patterns take priority over --include 
    -w, --word-regex            - the expression is searched for as a word (as if surrounded by [[:<:]] and [[:>:]])
    -E                          - interprets pattern as an extended regex - i.e. force grep to behave as egrep (why not just use egrep?)
    -e, --regexp=<pattern>      - specify a pattern used during the search 
    -S                          - if -R is specified, all symbolic links are followed. The default is to not follow symbolic links 
    -s                          - silent mode. nonexistent and unreadable files are ignored & their error messages suppressed 
    -A <number>                 - print <number> lines of trailing context for each match 
    -C <number>                 - print <number> lines of leading AND trailing context for each match 
    -U, --binary                - search binary files, but do not attempt to print them
    -m <number>                 - stop reading the file after <number> matches 

there's also a zgrep series of functions that accept files compressed with gzip() or compress()
GREP_OPTIONS environment variable can be used to specify default options 
grep exits with 0 if it found lines, 1 if it found nothing, >1 for error 

    grep "ian" <file>                   - find all occurrences of my name in a file
    grep "\.jpg" <file>                 - quotation marks prevent shell from misinterpreting the pattern
    grep -v -e "foo" -e "bar <file>     - find all lines that don't contain foo or bar 
    egrep "19|20|25" <file>             - simple regex, look for any of those numbers 

______________________________________________________

cmp and diff are two commands used for comparing files. cmp works on binary, and is typically used to check that the files are the same. It's also faster than diff. 
diff works only on text and by default it prints out the line differences

    cmp [options] <file1> <file2>       - compare 2 files byte by byte 

noteworthy cmp options: 
    -b, --print-bytes           - print differing bytes 
    -l, --verbose               - output byte numbers & values for differing bytes 
    -n <limit>                  - compare at most <limit> bytes 
    -s, --silent                - output nothing, yield exit status only 


    diff [options] <file1> <file2> 

noteworthy diff commands: 

    -i, --ignore-case           - ignore case in comparison 
    --from-file=<file1>         - compare <file1> to all operands. <file1> can be a directory 
    --to-file=<file2>           - compare <file2> to all operands. <file2> can be a directory 
    -t                          - expand tabs to spaces in output (mysterious that this was selected. does it avoid tabs vs spacing diff issues, ...? Doesn't read like it)
    -u <number>                 - output <number> (default 3) lines of unified context 
    -r                          - recursively compare any subdirectories found 
    --label <label>             - use <label> instead of filename 
    -w, --ignore-all-space      - ignore all whitespace 
    -b, --ignore-space-change   - ignore spaces in the amount of whitespace

if the input file is "-" diff will read that file from stdin instead
regarding the mysterious -t option, apparently the spacing between columns is 8 spaces with -t on. tabs may also be too wide. 
they suggested this command to reduce tabs to 4 spaces:
    diff -t <(expand -t4 file1.txt) <(expand -t4 file2.txt)

______________________________________________________

in UNIX it's a "rule" that wherever you can use a filename you can use a pathname (whether it's practical or always supported I'm not sure)

when you run a command by typing its name, UNIX first searches the current directory, then /bin and /usr/bin
these various UNIX user-level programs (ls, who, etc.) are located in /bin 

______________________________________________________

the shell supports regex's for use in filename matching

    cat *.txt           - cat any .txt file
    ls S*
    ls [a-z]*           - list any file starting w/ lowercase letters 
    ls ?                - list files with 1 character of any type in the name 
    ls '?'              - bypass regex shell interpretation, list file named "?" (is that even a valid name?)
    ls \?               - bypass regex shell interpretation
    ls /usr/*/file      - regex's can be used within pathnames as well. * won't do a recursive search of folders, only on the level it's specified 


the use of ls * also lists directory contents. It seems there is a special format ls uses for printing a directory 

______________________________________________________

    cd                  - cd by itself returns you to your personal directory located in /usr 

    rmdir <directory>   - this will only remove an empty directory 

    pr <file>           - this prepares a file for printing by adding footers, headers, margins, & formatted text. read about its various options if you want to use it 

    echo "print this"   - the echo command just outputs the argument to the console 

______________________________________________________

output redirection w/ > will overwrite the contents of old files, so beware
to append to the file, use >> instead of > 

    cat file1 > file2                       - file1 overwrites file2
    cat file1 >> file2                      - file1 is appended to file2 

there's also input redirection, where the program will use the file as input: 

    program.py < inputfile 

io redirection is the shell changing stdin of the program. 
UNIX user-level programs default to using stdin if no filenames are specified as arguments. 
if filenames are specified they're opened & read instead (and there may be a list of files) 

one technique is to chain commands using temp files

    who > temp 
    sort < temp                             - display the sorted list of users 

pipes implement the same behavior without you having to create the temporary file yourself

    who | sort                              - display the sorted list of users 

pipes are just a chain of one programs output into another programs input
the programs in a pipe all run simultaneously
stderr was created to avoid passing errors along the pipeline. stderr isn't rerouted by pipes and is still printed to the terminal

______________________________________________________

separate two commands by semicolon (;) for the shell to run them sequentially: 

    who; date 

run a process in the backgorund using ampersand (&) 
it's often useful to combine this with > to redirect output into a file - so that its output wont interrupt you when it finishes running 

    wc /* > wc.out &
