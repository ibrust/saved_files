------------------------------------------------------------------------------------
------------------------------------CHAPTER 1---------------------------------------
------------------------------------------------------------------------------------
my testing in this book was conducted on a BSD system (Darwin, Mac OS X Catalina)

control characters for the terminal: 
    ctrl+d - the shell instructs the running process that input is ended. it will actually terminate the shell process itself if you use it at the shell prompt 
    ctrl+g - rings a bell 
    ctrl+i - tab 
    ctrl+m - alternative to the enter key 
    ctrl+c 
    ctrl+u - line kill (discards the line of input)
    ctrl+s - suspend a processes output (not sure of the details). useful for preventing something important from going offscreen, apparently
    ctrl+q - resume a processes output (again not sure of the details)

______________________________________________________
misc UNIX terminal commands: 
    date
    who                 - who is using the computer
    who am i            - your username 
    mail                - can read mail apparently. not sure what email system is being used here. there are details if you're ever interested

you can type-ahead while a prior command is running; your input may appear interleaved with output, but the system will interpret your command correctly 
______________________________________________________
ls is an important UNIX function, and has about 40 commands, most of which are worth knowing:
    ls [options] [file/path]
    ls                  - list files in current directory 
    ls <filename>       - list a specific file 
    ls -l               - long description format: file mode | # of links | owner name | group name | file size | month/day/hour/minute last modified | pathname 
                                for directories it also lists the total blocks used by files within on a separate line 
    ls -l <filename>    - long description of a specific file
    ls -l -t            
    ls -lt              - you can combine multiple options 

                // SORTING OPTIONS 
    ls -t               - sort by time last modified
    ls -rt              - reverses the order of a sort 
    ls -u               - sort by time of last access 
    ls -U               - sort by file creation time 
    ls -S               - sort by size 
    ls -c               - sort by time when file status was last changed 

                // DIRECTORY RELATED OPTIONS 
    ls <pathname>       - list files at a specific path 
    ls -R               - recursively list subdirectories 
    ls -d               - directories are listed as plain files (not searched recursively) 
    ls -A               - list all entries except for . and .. (this is always set for the superuser) 
    ls -a               - include directory entries whose name begins with a dot (.) 

                // SYMBOLIC LINK HANDLING 
                // -H, -L, and -P all override one another - the last one specified is the one used 
    ls -H               - symbolic links on the command line are followed. this option is assumed none if -F, -d, or -l are specified 
    ls -L               - follow all symbolic links to final target. list the file or directory rather than the link itsel
    ls -P               - list the link itself rather than the object the link references 

                // OUTPUT FORMATTING OPTIONS
                // -1, -C, -x, and -l override one another - the last one specified is used
    ls -C               - force multi-column output (the default behavior if output is to a terminal). note: overrides -l 
    ls -x               - same as -C, but columns are filled in horizontally instead of vertically (test it and look). note: overrides -l 
    ls -1               - force output to be one entry per line (the default if output is NOT to a terminal). note: overrides -l 

                // -B, -q, and -w override one another - the last one specified is used
    ls -B               - force printing of non-printable characters in file names 
    ls -q               - force printing of non graphic characters to be ? (the default behavior if output is to a terminal)
    ls -v               - force unedited printing of non-graphic characters (the default behavior if output is NOT to a terminal) 
    ls -w               - force raw printing of non-graphic characters (the default behavior if output is NOT to a terminal) 

                // FILE ANNOTATION OPTIONS 
    ls -p               - display '/' after each directory path 
    ls -F               - display '/' after each directory path, * after each executable, @ after each link, = after each socket, % after each whiteout, | after each FIFO 
    ls -%               - display '%' after dataless files (whiteout?), and don't materialize dataless directories when listing them 

                // LONG FORMAT SPECIFIC OPTIONS 
    ls -lh              - use suffixes for unit sizes (i.e. kilobyte, megabyte) (must combine with -l)
    ls -lO              - include the file flags (must combine with -l)
    ls -l@              - display extended attribute keys and sizes (must combine with -l)
    ls -le              - print the access control list (ACL) associated with the file, if present (must combine with -l)
    ls -lo              - omit group id (must combine with -l)
    ls -lT              - display complete date/time information (must combine with -l)

                // MISC OPTIONS
    ls -i               - print the inode# for each file 
    ls -G               - enable colored output (equivalent to defining CLICOLOR in the environment)
    ls -m               - stream output, listing files in CSV format 
    ls -n               - display user or group names as numbers rather than converting them to names. this turns on long priting (-l) automatically 

    ls -s               - display the # of blocks used by each file in units of BLOCKSIZE (environment variable) or 512 bytes by default. 
    ls -ks              - combined with -s, prints the file sizes in kb instead (so this overrides BLOCKSIZE or the default 512)

some example commands: 
    ls /                - output everything in the root directory 
    ls /usr             - list what's in the /usr directory
    
    ls -l 
    total 4296
    drwxr-xr-x@   6 vn51hvk  staff      192 May  4 00:23 Walmart.xcodeproj
    drwxr-xr-x    4 vn51hvk  staff      128 May  3 20:51 Carthage

______________________________________________________

    cat <file1> <file2>         - cat can concatenate multiple files & print their contents 
    less <filename>             - show the file in a scrollable form

    wc <file1> <file2>          - print line, word, & character counts of file(s)
        69760  140992 1998523 schema.json
    wc -l                       - print only line counts 

    tail -<number> <file>       - print the last <number> lines of a file, or default of 10 
    tail +<number> <file>       - print the remainder of the file starting at line <number> 

    sort <filename>             - sorts the lines in the file alphabetically & prints them 

common sort options: 
    -r                              - reverse sort order 
    -n                              - sort in numerical order, ignoring blanks 
    -nr 
    -f, --ignore-case               - ignore case when sorting 
    -b, --ignore-leading-blanks     - ignore leading blank characters 
    -R, --random-sort               - random permutation of the inputs except that equal keys sort together. the hash function used for comparison is chosen randomly 
______________________________________________________

    grep <pattern> <file ...>       - searches a file for a regex pattern, prints each lines occurrence
    grep -v <pattern> <file ...>    - searches for all lines without the pattern 

more noteworthy grep options: 
    -R, -r                      - recursively search subdirectories listed 
    --include-dir               - if -R is specified (for recursive), only directories matching a given filename pattern are searched. 
    --exclude-dir               - if -R is specified it excludes directories matching a given filename pattern from the search. 
                                    --exclude-dir patterns take priority over --include-dir 
    --include                   - if specified it includes directories matching a given filename pattern from the search. 
    --exclude                   - if specified it excludes directories matching a given filename pattern from the search. 
                                    --exclude patterns take priority over --include 
    -w, --word-regex            - the expression is searched for as a word (as if surrounded by [[:<:]] and [[:>:]])
    -E                          - interprets pattern as an extended regex - i.e. force grep to behave as egrep (why not just use egrep?)
    -e, --regexp=<pattern>      - specify a pattern used during the search 
    -S                          - if -R is specified, all symbolic links are followed. The default is to not follow symbolic links 
    -s                          - silent mode. nonexistent and unreadable files are ignored & their error messages suppressed 
    -A <number>                 - print <number> lines of trailing context for each match 
    -C <number>                 - print <number> lines of leading AND trailing context for each match 
    -U, --binary                - search binary files, but do not attempt to print them
    -m <number>                 - stop reading the file after <number> matches 

there's also a zgrep series of functions that accept files compressed with gzip() or compress()
GREP_OPTIONS environment variable can be used to specify default options 
grep exits with 0 if it found lines, 1 if it found nothing, >1 for error 

    grep "ian" <file>                   - find all occurrences of my name in a file
    grep "\.jpg" <file>                 - quotation marks prevent shell from misinterpreting the pattern
    grep -v -e "foo" -e "bar <file>     - find all lines that don't contain foo or bar 
    egrep "19|20|25" <file>             - simple regex, look for any of those numbers 

______________________________________________________

cmp and diff are two commands used for comparing files. cmp works on binary, and is typically used to check that the files are the same. It's also faster than diff. 
diff works only on text and by default it prints out the line differences

    cmp [options] <file1> <file2>       - compare 2 files byte by byte 

noteworthy cmp options: 
    -b, --print-bytes           - print differing bytes 
    -l, --verbose               - output byte numbers & values for differing bytes 
    -n <limit>                  - compare at most <limit> bytes 
    -s, --silent                - output nothing, yield exit status only 


    diff [options] <file1> <file2> 

noteworthy diff commands: 

    -i, --ignore-case           - ignore case in comparison 
    --from-file=<file1>         - compare <file1> to all operands. <file1> can be a directory 
    --to-file=<file2>           - compare <file2> to all operands. <file2> can be a directory 
    -t                          - expand tabs to spaces in output (mysterious that this was selected. does it avoid tabs vs spacing diff issues, ...? Doesn't read like it)
    -u <number>                 - output <number> (default 3) lines of unified context 
    -r                          - recursively compare any subdirectories found 
    --label <label>             - use <label> instead of filename 
    -w, --ignore-all-space      - ignore all whitespace 
    -b, --ignore-space-change   - ignore spaces in the amount of whitespace

if the input file is "-" diff will read that file from stdin instead
regarding the mysterious -t option, apparently the spacing between columns is 8 spaces with -t on. tabs may also be too wide. 
they suggested this command to reduce tabs to 4 spaces:
    diff -t <(expand -t4 file1.txt) <(expand -t4 file2.txt)

______________________________________________________

in UNIX it's a "rule" that wherever you can use a filename you can use a pathname (whether it's practical or always supported I'm not sure)

when you run a command by typing its name, UNIX first searches the current directory, then /bin and /usr/bin
these various UNIX user-level programs (ls, who, etc.) are located in /bin 

______________________________________________________

the shell supports regex's for use in filename matching

    cat *.txt           - cat any .txt file
    ls S*
    ls [a-z]*           - list any file starting w/ lowercase letters 
    ls ?                - list files with 1 character of any type in the name 
    ls '?'              - bypass regex shell interpretation, list file named "?" (is that even a valid name?)
    ls \?               - bypass regex shell interpretation
    ls /usr/*/file      - regex's can be used within pathnames as well. * won't do a recursive search of folders, only on the level it's specified 


the use of ls * also lists directory contents. It seems there is a special format ls uses for printing a directory 

______________________________________________________

    cd                  - cd by itself returns you to your personal directory located in /usr 

    rmdir <directory>   - this will only remove an empty directory 

    pr <file>           - this prepares a file for printing by adding footers, headers, margins, & formatted text. read about its various options if you want to use it 

    echo "print this"   - the echo command just outputs the argument to the console 

______________________________________________________

output redirection w/ > will overwrite the contents of old files, so beware
to append to the file, use >> instead of > 

    cat file1 > file2                       - file1 overwrites file2
    cat file1 >> file2                      - file1 is appended to file2 

there's also input redirection, where the program will use the file as input: 

    program.py < inputfile 

io redirection is the shell changing stdin of the program. 
UNIX user-level programs default to using stdin if no filenames are specified as arguments. 
if filenames are specified they're opened & read instead (and there may be a list of files) 

one technique is to chain commands using temp files

    who > temp 
    sort < temp                             - display the sorted list of users 

pipes implement the same behavior without you having to create the temporary file yourself

    who | sort                              - display the sorted list of users 

pipes are just a chain of one programs output into another programs input
the programs in a pipe all run simultaneously
stderr was created to avoid passing errors along the pipeline. stderr isn't rerouted by pipes and is still printed to the terminal

______________________________________________________

separate two commands by semicolon (;) for the shell to run them sequentially: 

    who; date 

run a process in the backgorund using ampersand (&) 
the command will run as a separate process from the shell, in the background, with its own PID. the PID is printed after running the command 
w/ one ampersand (&), all commands in a pipeline will run on separate processes in the background. However, only one PID (the last process) will be printed to the terminal 
it's often useful to combine this with > to redirect output into a file - so that its output wont interrupt you while you're doing other things 

    ls -R /* > output &                     - list every single file in the file system 
    pr file1 | sort &                       - pr & sort both run on their own separate background processes 

if you need to terminate the background process: 

    ps                              - ps shows PIDs of all processes that have controlling terminals. top, in contrast, shows all processes in real time 
    kill <PID> 

to wait for all background processes started w ampersand (&) to finish: 

    wait                            - if wait doesn't return immediately, background processes are still running

if you close the terminal its children will also be killed - including any background processes. to prevent this use the nohup command (no hangup)
this command doesn't appear to work in mac OS, but it may work on other systems: 

    nohup ls -R /* > output & 

to run your command at lower scheduling priority (so it won't block other commands), use nice. nohup automatically calls nice: 

    nice <command> & 

you can also tell multiple commands to run at a specific time in the future using the at command 
it's often useful to combine at with an input redirected file containing a list of commands: 

    at 3am < file_listing_commands 

______________________________________________________

search for files with the find command: 

    find [-L | -P] [-Edsx] [-f path] [expression]

the search expression is composed of primaries and operands. operands are standard logical operands used on the primaries

            // OPTIONS 
    -f                  - specify a file hierarchy to search 

    -E                  - use extended regex's rather than regular regex's 
    -d                  - cause find to do a post-order search or directories (preorder is the default) 
    -s                  - cause find to search the directories in alphabetical order 
    -x                  - prevent find from descending into directories with a device number different than where the search began (so no mounted filesystem search, etc.)

    -L                  - use the file symbolic links resolve to for evaluating the search criteria, rather than the link itself
    -P                  - use symbolic links for evaluating the search criteria, rather than the files they resolve to (this is the default)

            // PRIMARIES 
    -name <filename>            - find the filename. remember you can use UNIX shell pattern matching in the filename 
    -atime <number>             - file was accessed <number> days prior. you can change it from days to another metric, like minutes 
    -mtime <number>             - file was modified <number> days prior 
    -size <number>              - specifies the file is <number> blocks in size  
    -user <name>                - specifies the files owner is user <name> 
    -group <name>               - specifies the files group is group <name> 
    -type <filetype>            - specifies the files type is: f=regular file, d=directory, l=symbolic link, p=FIFO, & more 
    -exec <utility> <arguments ...>         - true if the <utility> program returns 0 value as its exit status 
    -execdir <utility> <arguments ...> {}   - same as exec, except that {} is replaced with as many pathnames as possible for each invocation of <utility>
    -xattrname <name>                       - true if the file has an extended attribute with the specified <name> (what are extended attributes?)
    -print                      - always true, prints the pathname of current file to stdout 
    -newerXY <file>             - true if file is newer than the evaluated XY parameters. XY are replaced with a, b, c, or m: 
                                            a (last access time) | b (inode creation time) | c (change time) | m (modification time) 
    -prune                      - don't descend into subdirectories 

            // OPERANDS 
    \! <expression>                                         - negation. notice \ is necessary to escape the character at the command line 
    -not <expression>                                       - another way of doing negation 
    <expression> -and <expression> 
    <expression> <expression>                               - another way of doing and - it's considered to be implied when expressions are neighboring 
    <expression> -or <expression>   
    \( <expression \)                                       - you can use parenthesis

some examples: 
    find /bin -newerct '1 minute ago' -print
            Print out a list of all the files in bin whose inode change time is more recent than the current time minus one minute.
    find / \! \( -newer file1 -user wnj \) -print
            Print out a list of all the files which are not both newer than file1 and owned by user "wnj"
    find / \( -mtime +7 -atime +30 \)
            find all files modified more than 7 days ago and accessed more than 30 days ago
______________________________________________________

the stty command can be used to configure the terminal, but it's complicated. read the man page for more details 

on UNIX you can specify configuration commands to run upon startup in the .profile file. this is not available on Mac it seems, and I'm not sure which versions have it. 
examples of what you might put in .profile: 

    who | wc -l                 - tell you how many users are logged into your system 
    /usr/games/fortune          - draw a fortune cookie (not there on Mac)

many properties of the shell are set by shell variables, and you can change their values

    PS1="$: "                   - PS1 is the shells prompt character 
    HOME                        - HOME is the name of your home directory. changing it breaks some applications, best to just leave it unless you really look into things 
    PATH=.:/bin:/usr/bin:/usr/ian/games         - PATH is probably the most important shell variable

remember "." is the current directory; thus we are setting the current directory as first in the search path 
It was at one point common practice to set the path in .profile. I'm not sure how commonm that is any more, or if the other variables should be set in .profile either. 
another way of setting path is using the current value: 

    PATH=$PATH:/usr/ian/games       - invoke the shell variables using $ 

you can et new shell variables to avoid typing redundant commands: 

    games=/usr/ian/games 
    cd $games

if you want to use these shell variables in programs you must export them: 

    export PATH                     - you don't use the $ syntax with export apparently 

there are many more commands in the manual, at some point you should explore the manual and see what else you can find. 

------------------------------------------------------------------------------------
------------------------------------CHAPTER 2---------------------------------------
------------------------------------------------------------------------------------
the od command will print the bytes in a file: 

    od -cx <file>

    -c              - interpret the bytes as characters 
    -x              - print hex numbers below the bytes 
    -b              - print octal numbers below the bytes 

-the terminal interprets special characters & adjusts its output (i.e. newlines \n, tabs \t, backspace \b, carriage return \r)
-if you print a file to terminal that contains a backspace character (\b, octal 10) it will actually erase the next character in the file that's output 
-od may be useful for finding strange characters such as these 

-the terminal can optionally extend tabs to a certain number of spaces. use stty to turn this feature on: 
    stty oxtabs             - expand tabs to spaces 
    stty -oxtabs            - do not expand tabs to spaces 

-to turn raw mode on and off you need to save the initial state of the terminal, apparently turning this off is buggy (in Mac OS, anyway): 

    save_state=$(stty -g)               - save terminals original state
    stty raw                            - turn on raw mode 
    ...
    stty "$save_state"                  - restore terminal to state before raw mode 

-similarly the terminal driver echoes the ENTER key as \n + \r, but stores only \n on input. On output, \n is expanded back to \r + \n. 
    Thus your files only contain what you put in them, no additional characters 

-some non-UNIX systems store the \n + \r (the terminal needs this apparently), 
    others store a 'record' at the end of each line that contains information like the lines character count 

-in UNIX, all files are ultimately accessed through read(), which returns 0 when the end of the file is reached. 
    Thus there need be no special character denoting EOF in UNIX.

______________________________________________________

-the UNIX system doesn't know what filetype a file is, but it can take an educated guess with the file command: 

    file <file1> <file2>            - ascertain & list the types of files (as best as possible) 

-the file command doesn't base its guess off file exensions. It reads the first few hundred bytes of the file & tries to guess what it is.
-part of why UNIX doesn't track the file types more carefully is it doesn't want to force programs to handle files differently based on their type 
-inspired by UNIX, the author gives general advice to think carefully before using non-textual file representations when designing programs 





page 48, section 2.3
